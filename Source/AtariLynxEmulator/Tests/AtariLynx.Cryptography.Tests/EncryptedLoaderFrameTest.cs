using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Diagnostics;
using System.IO;
using KillerApps.Emulation.Atari.Lynx.Cryptography;
using System.Security.Cryptography;

namespace AtariLynx.Encryption.Tests
{
	/// <summary>
	/// Summary description for EncryptedBootFrameTest
	/// </summary>
	[TestClass]
	public class EncryptedLoaderFrameTest
	{
		public EncryptedLoaderFrameTest() { }

		private TestContext testContextInstance;

		/// <summary>
		///Gets or sets the test context which provides
		///information about and functionality for the current test run.
		///</summary>
		public TestContext TestContext
		{
			get
			{
				return testContextInstance;
			}
			set
			{
				testContextInstance = value;
			}
		}

		#region Additional test attributes
		//
		// You can use the following additional attributes as you write your tests:
		//
		// Use ClassInitialize to run code before running the first test in the class
		// [ClassInitialize()]
		// public static void MyClassInitialize(TestContext testContext) { }
		//
		// Use ClassCleanup to run code after all tests in a class have run
		// [ClassCleanup()]
		// public static void MyClassCleanup() { }
		//
		// Use TestInitialize to run code before running each test 
		// [TestInitialize()]
		// public void MyTestInitialize() { }
		//
		// Use TestCleanup to run code after each test has run
		// [TestCleanup()]
		// public void MyTestCleanup() { }
		//
		#endregion

		byte[] originalFrameData = new byte[3 * BootLoaderCryptoAlgorithm.DecryptedBlockSize]
		{
			0x80, 0x00, 0x20, 0x4f, 0x02, 0x64, 0x05, 0xe6, 0x06, 0xa9, 0x08, 0x8d, 0x8b, 0xfd, 0x4c, 0x4a,
			0xfe, 0xa0, 0x06, 0x20, 0x00, 0x03, 0xa2, 0x0b, 0xbd, 0x6d, 0x02, 0xbc, 0x76, 0x02, 0x99, 0x00,
			0xfc, 0xca, 0xd0, 0xf4, 0x9c, 0x91, 0xfd, 0xa0, 0x1f, 0xb9, 0x00, 0x60, 0x99, 0xa0, 0xfd, 0x88,
			0x10, 0xf7, 0xa9, 0x04, 0x8d, 0x95, 0xfd, 0x8a, 0x9d, 0x00, 0x24, 0xe8, 0xd0, 0xf9, 0x4c, 0x49,
			0x03, 0x01, 0x02, 0x00, 0x00, 0x60, 0xac, 0x10, 0x09, 0xae, 0x00, 0x00, 0x04, 0xc3, 0x8d, 0xa2,
			0x1f, 0x9e, 0xa0, 0xfd, 0xca, 0x10, 0xfa, 0xa9, 0x04, 0x8d, 0x8c, 0xfd, 0xa9, 0x0f, 0x8d, 0x01,
			0x02, 0x60, 0xa2, 0x07, 0xb9, 0x41, 0x02, 0x95, 0x35, 0x88, 0xca, 0xd0, 0xf7, 0x60, 0x01, 0x20,
			0x04, 0x00, 0x01, 0x00, 0x00, 0x60, 0x20, 0x91, 0x92, 0x09, 0x08, 0x90, 0x04, 0x06, 0x11, 0x10,
			0x28, 0x2a, 0x47, 0x39, 0x00, 0x12, 0xaf, 0xf2, 0xe1, 0x27, 0x8e, 0x05, 0xb3, 0x5d, 0x36, 0xe9,
			0x9f, 0x72, 0xe5, 0x49, 0xdc, 0x00
		};

		byte[] encryptedFrameData = new byte[1 + 3 * BootLoaderCryptoAlgorithm.EncryptedBlockSize]
			{
				0xFD, 
				0xB8, 0xC3, 0xD8, 0xCC, 0xE6, 0x72, 0xCE, 0xDC, 0xA5, 0xAE, 0xEF, 0x59, 0xEF, 0xF7, 0x8D, 0x9E, 
				0xA4, 0x3F, 0x74, 0xDB, 0x80, 0xF5, 0x46, 0x9F, 0x7D, 0x8B, 0xEF, 0xFB, 0x83, 0x68, 0x80, 0x4E, 
				0x23, 0x2A, 0xF3, 0x5B, 0xA4, 0x6E, 0xE8, 0xBF, 0xB7, 0x2B, 0x04, 0xE6, 0x84, 0xE5, 0x4C, 0x94, 
				0xB6, 0x82, 0x0D, 0xAD, 0x96, 0x41, 0x3A, 0x98, 0xDD, 0x83, 0x5B, 0x09, 0xFA, 0x62, 0x36, 0xDB, 
				0xA1, 0xFD, 0x61, 0xFF, 0x73, 0xFE, 0x12, 0x3E, 0xE2, 0xA1, 0xCC, 0xCC, 0x9A, 0xC6, 0x6F, 0x35, 
				0x91, 0xBA, 0x05, 0x62, 0xE2, 0x9A, 0xC9, 0x02, 0x45, 0xF3, 0x77, 0xE0, 0xA2, 0xDA, 0xFF, 0x0F, 
				0x48, 0x17, 0x51, 0x96, 0x3C, 0x21, 0xEF, 0x32, 0x4F, 0x2D, 0x11, 0x5F, 0x64, 0xFB, 0xEA, 0x08, 
				0xAF, 0x18, 0xDA, 0xB5, 0xF9, 0x00, 0xAD, 0xEC, 0x4E, 0xC1, 0x57, 0x65, 0x61, 0xB1, 0x8B, 0xE1, 
				0x6A, 0x03, 0x64, 0x89, 0x4D, 0x45, 0xB8, 0x19, 0x68, 0xB3, 0x2B, 0x19, 0x58, 0xBD, 0xBA, 0x43, 
				0x08, 0x62, 0xC9, 0xF5, 0x4F, 0x65, 0x8E, 0x58, 0x1C
			};

		byte[] encryptedSingleBlockFrameData = new byte[52]
			{
				0xff, 
				0x88, 0x6c, 0x24, 0xd0, 0xf5, 0x9a, 0x62, 0x8c, 0xa1, 0x08, 0x7e, 0xda, 0x87, 0x3f, 0x1b, 0xeb, 
				0x48, 0x50, 0xba, 0x0d, 0xc9, 0xcb, 0x7b, 0x3e, 0x10, 0x7c, 0xfd, 0x7e, 0xde, 0x8c, 0x06, 0x3a, 
				0x12, 0x35, 0x1a, 0x8c, 0x74, 0x07, 0xdb, 0xd1, 0x60, 0x7e, 0xe5, 0x88, 0x90, 0x60, 0x5b, 0x2e, 
				0x4b, 0xa2, 0x25
			};

		byte[] originalSingleBlockFrameData = new byte[50]
			{
			  0x9c, 0xf9, 0xff, 0xa9, 0x03, 0x8d, 0x8a, 0xfd, 0xa9, 0x04, 0x8d, 0x8c, 0xfd, 0xa9, 0x08, 0x8d, 
				0x8b, 0xfd, 0xa2, 0x00, 0xad, 0xb2, 0xfc, 0x9d, 0x00, 0x03, 0xe8, 0xd0, 0xf7, 0x4c, 0x00, 0x03, 
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00
			};

		[TestMethod]
		public void LoadingFromStreamShouldCreateCorrectFrame()
		{
			Stream stream = new MemoryStream(encryptedFrameData);

			EncryptedLoaderFrame frame = EncryptedLoaderFrame.Load(stream);

			Assert.IsNotNull(frame, "Correct stream should give actual frame.");
			Assert.AreEqual<int>(0xFD, frame.Header, "Header from stream is not correct.");
			Assert.AreEqual<int>(3, frame.BlockCount, "Block count should be set correctly.");
		}

		[TestMethod]
		public void DecryptingSingleBlockFrameShouldReturnCorrectData()
		{
			Stream stream = new MemoryStream(encryptedSingleBlockFrameData);
			EncryptedLoaderFrame frame = EncryptedLoaderFrame.Load(stream);

			byte[] data = frame.Decrypt();

			Assert.AreEqual<int>(BootLoaderCryptoAlgorithm.DecryptedBlockSize, data.Length, "Decrypted data should be of correct length.");
			CollectionAssert.AreEqual(originalSingleBlockFrameData, data);
		}

		[TestMethod]
		public void DecryptingMultiBlockFrameShouldReturnCorrectData()
		{
			Stream stream = new MemoryStream(encryptedFrameData);
			EncryptedLoaderFrame frame = EncryptedLoaderFrame.Load(stream);

			byte[] data = frame.Decrypt();

			Assert.AreEqual<int>(frame.BlockCount * BootLoaderCryptoAlgorithm.DecryptedBlockSize, data.Length, "Decrypted data should be of correct length.");
			CollectionAssert.AreEqual(originalFrameData, data, "Decrypted data should match known decryption values");
		}

		[TestMethod]
		public void EncryptingMultiBlockFrameShouldReturnCorrectData()
		{
			EncryptedLoaderFrame frame = EncryptedLoaderFrame.Create(originalFrameData);
			byte[] data = frame.GetBytes();

			Assert.AreEqual<int>(3, frame.BlockCount);
			Assert.AreEqual<byte>(0xFD, frame.Header, "Header should indicate 3 blocks.");
			Assert.AreEqual<int>(3 * BootLoaderCryptoAlgorithm.EncryptedBlockSize + 1, data.Length, "Encrypted data should be of correct length.");
			CollectionAssert.AreEqual(encryptedFrameData, data, "Encrypted data should match known encryption values");
		}

		[TestMethod]
		public void LoadingFromStreamWithWrongHeaderShouldThrow()
		{
			Stream stream = new MemoryStream(new byte[] { 0x00 });

			try
			{
				EncryptedLoaderFrame frame = EncryptedLoaderFrame.Load(stream); 
			}
			catch (Exception ex)
			{
				Assert.IsInstanceOfType(ex, typeof(ArgumentException), "Wrong header data should throw as bad argument." );
				Assert.AreEqual<string>("Invalid header information in stream.", ex.Message);
				return;
			}

			Assert.Fail("Exception should have been thrown for data with bad header.");
		}

		[TestMethod]
		public void LoadingFromStreamWithWrongSizeShouldThrow()
		{
			Stream stream = new MemoryStream(new byte[] { 0xFD });

			try
			{
				EncryptedLoaderFrame frame = EncryptedLoaderFrame.Load(stream);
			}
			catch (Exception ex)
			{
				Assert.IsInstanceOfType(ex, typeof(ArgumentException), "Wrong header data should throw as bad argument.");
				Assert.AreEqual<string>("Stream does not contain enough data.", ex.Message);
				return;
			}

			Assert.Fail("Exception should have been thrown for data with incorrect length.");
		}
	}
}
